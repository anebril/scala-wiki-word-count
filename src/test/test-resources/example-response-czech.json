{
  "batchcomplete": "",
  "query": {
    "pages": {
      "482165": {
        "pageid": 482165,
        "ns": 0,
        "title": "Scala (programovac\u00ed jazyk)",
        "revisions": [
          {
            "contentformat": "text/x-wiki",
            "contentmodel": "wikitext",
            "*": "{{Infobox - programovac\u00ed jazyk\n|n\u00e1zev =Scala\n|logo =[[File:Scala logotipo.jpg]] \n|paradigma = [[multiparadigmatick\u00fd programovac\u00ed jazyk|multiparadigmatick\u00fd]]\n|vznik = [[2003]]\n|autor = [[Martin Odersky]]\n|v\u00fdvoj\u00e1\u0159 = \n| posledn\u00ed verze  = 2.11.8\n| datum posledn\u00ed verze = [[8. b\u0159ezen|8. b\u0159ezna]] [[2016]]\n| posledn\u00ed testovac\u00ed verze = \n| datum posledn\u00ed testovac\u00ed verze= \n|typov\u00e1n\u00ed =Statick\u00e9 \n|implementace = \n|dialekty = \n|ovlivn\u011bno = [[Java (programovac\u00ed jazyk)|Java]], [[Pizza (programovac\u00ed jazyk)|Pizza]], [[Haskell (programovac\u00ed jazyk)|Haskell]], [[Erlang (programovac\u00ed jazyk)|Erlang]], [[Standard ML]], [[Objective Caml]], [[Smalltalk]], [[Scheme]]\n|ovlivnil = \n| opera\u010dn\u00ed syst\u00e9m =\n|licence = [[BSD]]\n|web = [http://www.scala-lang.org/ www.scala-lang.org]\n}}\n'''Scala''' je [[multiparadigmatick\u00fd programovac\u00ed jazyk]] navr\u017een\u00fd tak, aby integroval rysy [[objektov\u011b orientovan\u00e9 programov\u00e1n\u00ed|objektov\u011b orientovan\u00e9ho]] a [[funkcion\u00e1ln\u00ed programov\u00e1n\u00ed|funkcion\u00e1ln\u00edho programov\u00e1n\u00ed]]. Jm\u00e9no Scala vzniklo z [[angli\u010dtina|anglick\u00e9ho]] \u201e''{{cizojazy\u010dn\u011b|en|scalable language}}''\u201c \u2013 \u0161k\u00e1lovateln\u00fd jazyk, proto\u017ee je navr\u017een tak, aby rostl s n\u00e1roky jeho u\u017eivatel\u016f. V [[ital\u0161tina|ital\u0161tin\u011b]] slovo \u201escala\u201c znamen\u00e1 schody, co\u017e  by v tomto kontextu tak\u00e9 mohlo m\u00edt v\u00fdznam.  \n\n==Historie==\n\nAutorem Scaly je Martin Odersky z [[\u0160v\u00fdcarsk\u00fd feder\u00e1ln\u00ed technologick\u00fd institut v Lausanne|\u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne]] (EPFL) ve \u0160v\u00fdcarsku, kter\u00fd ji\u017e p\u0159ed t\u00edm pracoval na [[Java (programovac\u00ed jazyk)|Jav\u011b]]: byl spoluautorem p\u0159eklada\u010de [[javac]] a roz\u0161\u00ed\u0159en\u00ed (superset) Generic Java.\nV\u00fdvoj Scaly za\u010dal v roce 2001. Prvn\u00ed verze pro platformu [[Java (programovac\u00ed jazyk)|Java]] vy\u0161la na konci [[2003]]/za\u010d\u00e1tku [[2004]], pak za p\u016fl roku v \u010dervnu [[2004]] uvid\u011bla sv\u011bt prvn\u00ed verze pro platformu [[.NET]]\n\n== Platformy a licence ==\n\nScala byla navr\u017eena tak, aby snadno pracovala na modern\u00edch virtu\u00e1ln\u00edch stroj\u00edch, hlavn\u011b na virtu\u00e1ln\u00edm stroji [[Java (programovac\u00ed jazyk)|Java]] ([[Java Virtual Machine|JVM]]). Hlavn\u00ed p\u0159eklada\u010d scaly (scalac) generuje Java class soubory spustiteln\u00e9 na [[Java_Virtual_Machine|JVM]]. Z pohledu virtu\u00e1ln\u00edho stroje jsou class soubory vygenerovan\u00e9 ze [[zdrojov\u00fd k\u00f3d|zdrojov\u00fdch k\u00f3d\u016f]] [[Java (programovac\u00ed jazyk)|Javy]] a Scaly principi\u00e1ln\u011b stejn\u00e9, lze je v\u0161ak obvykle odli\u0161it podle pou\u017eit\u00e9 standardn\u00ed knihovny, fingerprintingu nebo informac\u00ed pro debugger.\n\nExistuje alternativn\u00ed implementace Scala pro platformu [[.NET]], av\u0161ak tato alternativa se vyv\u00edj\u00ed relativn\u011b pomalu.\n\nScala m\u00e1 stejn\u00fd kompila\u010dn\u00ed model jako [[Java (programovac\u00ed jazyk)|Java]] a [[C Sharp|C#]] (odd\u011blen\u00e1 kompilace, dynamick\u00e9 nahr\u00e1v\u00e1n\u00ed t\u0159\u00edd), tak\u017ee m\u016f\u017ee Scala k\u00f3d vyu\u017e\u00edvat [[Java (programovac\u00ed jazyk)|Java]] knihovny (resp. [[.NET]] knihovny v alternativn\u00ed implementaci).\n\nSoftwarov\u00e1 distribuce Scala obsahuje p\u0159eklada\u010d a knihovny. Je uvol\u0148ov\u00e1na pod [[BSD]] licenc\u00ed.\n\n==Zvl\u00e1\u0161tnosti syntaxe==\nScala je navr\u017eena tak, aby byla zp\u011btn\u011b kompatibiln\u00ed s [[Java (programovac\u00ed jazyk)|Javou]], ale nejde o roz\u0161\u00ed\u0159en\u00ed Javy. Scala je zcela nov\u00fd programovac\u00ed jazyk, kter\u00fd se nesna\u017e\u00ed za ka\u017edou cenu nav\u00e1zat na [[Java (programovac\u00ed jazyk)|Javu]], [[Lisp]], [[Smalltalk]] \u010di jin\u00fd velk\u00fd vzor. Zku\u0161en\u00fd program\u00e1tor nicm\u00e9n\u011b ur\u010dit\u011b v syntaxi Scaly najde prvky zn\u00e1m\u00e9 z jin\u00fdch programovac\u00edch jazyk\u016f. Na druh\u00e9 stran\u011b v\u0161ak Scala  p\u0159edkl\u00e1d\u00e1 nov\u00e9 jazykov\u00e9 konstrukce, kter\u00e9 nejsou v  p\u0159edchoz\u00edch jazyc\u00edch obsa\u017eeny.\nNejprve si uk\u00e1\u017eeme, jak deklarovat ve Scale [[Funkce (programov\u00e1n\u00ed)|prom\u011bnn\u00e9]] a [[Funkce (programov\u00e1n\u00ed)|funkce]], proto\u017ee bez pou\u017eit\u00ed t\u011bchto konstrukc\u00ed nen\u00ed mo\u017en\u00e9 uv\u00e9st \u017e\u00e1dn\u00fd p\u0159\u00edklad. Deklarace prom\u011bnn\u00e9 vypad\u00e1 n\u00e1sledovn\u011b:\n   <source lang=\"scala\">var n\u00e1zev_prom\u011bnn\u00e9[:datov\u00fd_typ][ = po\u010d\u00e1te\u010dn\u00ed_hodnota]</source>\nPokud chceme, abychom prom\u011bnnou nemohli m\u011bnit, sta\u010d\u00ed m\u00edsto ''var'' pou\u017e\u00edt kl\u00ed\u010dov\u00e9 slovo def. Jde o obdobu kl\u00ed\u010dov\u00e9ho slova ''final'' z Javy.\nDeklarace funkce (metody) m\u00e1 tvar:\n   <source lang=\"scala\">def n\u00e1zev_funkce [(seznam_parametr\u016f)][:typ_n\u00e1vratov\u00e9_hodnoty] = t\u011blo_funkce</source>\n\nPozn\u00e1mka: hranat\u00e9 z\u00e1vorky p\u0159i popisu pravidel z\u00e1pisu konstrukce jazyka znamenaj\u00ed, \u017ee jejich obsah je voliteln\u00fd (je mo\u017en\u00e9 ho vynechat). \n \nJednou z u\u017eite\u010dn\u00fdch a d\u016fle\u017eit\u00fdch vlastnost\u00ed Scaly je jej\u00ed stru\u010dnost. Scala m\u00e1 stru\u010dnost dynamick\u00fdch jazyk\u016f jako Ruby nebo Python, ale je staticky typovan\u00e1 jako Java nebo [[Pascal (programovac\u00ed jazyk)|Pascal]].\nJe to mo\u017en\u00e9 d\u00edky tomu, \u017ee Scala m\u00e1 velmi dobr\u00fd p\u0159eklada\u010d, kter\u00fd se star\u00e1 o celou \u0159adu v\u011bc\u00ed. D\u011bl\u00e1 spoustu optimalizac\u00ed, konverz\u00ed apod., \u010d\u00edm\u017e \u0161et\u0159\u00ed program\u00e1torovi \u010das a umo\u017e\u0148uje ps\u00e1t krat\u0161\u00ed k\u00f3d.\nNap\u0159\u00edklad, v\u011bt\u0161inou nen\u00ed nutn\u00e9 uv\u00e1d\u011bt typ definovan\u00e9 konstanty nebo prom\u011bnn\u00e9. M\u00edsto\n<source lang=\"scala\">var msg: String = \"Hello, world!\";</source>\nlze napsat\n<source lang=\"scala\">var msg = \"Hello, world!\";</source>\nP\u0159eklada\u010d pozn\u00e1 hodnotu, kterou je [[prom\u011bnn\u00e1]] inicializov\u00e1na a podle toho p\u0159id\u00e1 k definici jej\u00ed [[datov\u00fd typ]]. \nOdvozov\u00e1n\u00ed datov\u00e9ho typu (type inference) funguje tak\u00e9 p\u0159i definov\u00e1n\u00ed metod. Nen\u00ed nutn\u00e9 explicitn\u011b uv\u00e1d\u011bt typ n\u00e1vratov\u00e9 hodnoty, p\u0159eklada\u010d ho v\u011bt\u0161inou zvl\u00e1dne ur\u010dit samostatn\u011b. Na druhou stranu, odvozov\u00e1n\u00ed typu nefunguje u parametr\u016f metod. Ka\u017ed\u00fd parametr mus\u00ed m\u00edt explicitn\u011b uveden\u00fd datov\u00fd typ.\n\nN\u011bkdy v\u0161ak odvozov\u00e1n\u00ed typu m\u016f\u017ee selhat. P\u0159eklada\u010d nedok\u00e1\u017ee ur\u010dit pou\u017eit\u00fd typ a vyhod\u00ed chybovou hl\u00e1\u0161ku. \nNeexistuje \u017e\u00e1dn\u00e9 p\u0159esn\u00e9 a jednoduch\u00e9 pravidlo, podle n\u011bho\u017e by program\u00e1tor mohl poznat, kdy je explicitn\u011b uv\u00e1d\u011bt datov\u00fd typ nutn\u00e9, a kdy je vhodn\u011bj\u0161\u00ed ponechat tuto pr\u00e1ci na p\u0159eklada\u010di.\n\nScala nab\u00edz\u00ed i \u0159adu dal\u0161\u00edch mo\u017enost\u00ed, jak u\u0161et\u0159it program\u00e1torovi pr\u00e1ci. Nap\u0159\u00edklad, p\u0159i vol\u00e1n\u00ed metod bez parametr\u016f lze vynechat kulat\u00e9 z\u00e1vorky (ps\u00e1t ''obj.metoda'' m\u00edsto ''obj.metoda()'' atd. Podle konvence se z\u00e1vorky vynech\u00e1vaj\u00ed jen tehdy, kdy\u017e metoda nem\u00e1 vedlej\u0161\u00ed efekt.\n\nScala tak\u00e9 umo\u017e\u0148uje odvodit nutnost pou\u017eit\u00ed lambda funkce. V n\u00e1sleduj\u00edc\u00edm k\u00f3du se p\u0159i kompilaci z dostupn\u00fdch metod odvod\u00ed, \u017ee ''from(x+1)'' mus\u00ed b\u00fdt lambda funkce. D\u00edky tomu je v\u00fdraz vyhodnotiteln\u00fd v kone\u010dn\u00e9m po\u010dtu krok\u016f, a\u010dkoli Scala pou\u017e\u00edv\u00e1 striktn\u00ed vyhodnocov\u00e1n\u00ed.\n<source lang=\"scala\">def from(x: BigInt) :Stream[BigInt] = Stream.cons(x, from(x+1))</source>\n\nI pokud lambda funkce po\u017eaduje n\u011bjak\u00e9 parametry, nen\u00ed v n\u011bkter\u00fdch p\u0159\u00edpadech nutn\u00e9 je pojmenov\u00e1vat:\n<source lang=\"scala\">List(1, 5, 6, 8).map(_*2) // v\u00fdsledkem bude List(2, 10, 12, 16)</source>\n\nTo n\u00e1m ale nezabra\u0148uje ps\u00e1t slo\u017eit\u011bj\u0161\u00ed lambda funkce:\n<source lang=\"scala\">\nimport Math.pow \nList(1, 5, 6, 8).map(x => pow(x, 3) + 2*pow(x, 2) + 9*x + 20)  \n                           // vyhodnot\u00ed se na List(32.0, 240.0, 362.0, 732.0)\n</source>\n\nV\u00fd\u0161e zm\u00edn\u011bn\u00e9 triky dovoluj\u00ed ps\u00e1t \u00fasporn\u011bj\u0161\u00ed, ale na druhou stranu m\u00e9n\u011b p\u0159ehledn\u00e9 zdrojov\u00e9 k\u00f3dy. Stru\u010dnost sice n\u011bkdy umo\u017e\u0148uje sn\u00e1ze porozum\u011bt k\u00f3du, ale v p\u0159\u00edpad\u011b nevhodn\u00e9ho pou\u017eit\u00ed m\u016f\u017ee m\u00edt \u010dten\u00e1\u0159 s porozum\u011bn\u00edm naopak probl\u00e9m. Scala nenut\u00ed pou\u017e\u00edvat n\u011bjak\u00fd p\u0159edem ur\u010den\u00fd styl, ale nab\u00edz\u00ed mo\u017enost v\u00fdb\u011bru.\n\n==Integrace s Javou==\nZa necel\u00fdch 15 let bylo v Jav\u011b naimplementov\u00e1no obrovsk\u00e9 mno\u017estv\u00ed [[T\u0159\u00edda (programov\u00e1n\u00ed)|t\u0159\u00edd]] pro \u0159e\u0161en\u00ed nejr\u016fzn\u011bj\u0161\u00edch \u00faloh. Velk\u00e1 v\u00fdhoda Scaly spo\u010d\u00edv\u00e1 v tom, \u017ee existuje mo\u017enost je p\u0159\u00edmo pou\u017e\u00edvat bez nutnosti p\u0159ekl\u00e1dat do Scaly nebo prov\u00e1d\u011bt jak\u00e9koliv zm\u011bny. \nVe\u0161ker\u00e9 v\u00fdchoz\u00ed t\u0159\u00eddy z bal\u00ed\u010dku ''java.lang'' u\u017e jsou importov\u00e1ny. T\u0159\u00eddy z jin\u00fdch bal\u00ed\u010dku je nutno importovat explicitn\u011b.\nUk\u00e1\u017eeme to na p\u0159\u00edkladu: \n<source lang=\"scala\">\nimport java.util.{Date, Locale}\nimport java.text.DateFormat\nimport java.text.DateFormat._\n\nobject FrenchDate {\n    def main(args: Array[String]) {\n        val now = new Date\n        val df = getDateInstance(LONG, Locale.FRANCE)\n        println(df format now)\n    }\n}\n</source>\nZ uveden\u00e9ho p\u0159\u00edkladu lze zjistit, \u017ee ve Scale je mo\u017en\u00e9 najednou importovat v\u00edce t\u0159\u00edd ze stejn\u00e9ho bal\u00ed\u010dku \u2013 sta\u010d\u00ed vyjmenovat jejich seznam ve svork\u00e1ch tak, jak je to uvedeno v prvn\u00edm \u0159\u00e1dku.\nDruh\u00e1 zaj\u00edmav\u00e1 v\u011bc je ta, \u017ee pokud chceme importovat v\u0161echno z bal\u00ed\u010dku (nebo t\u0159\u00eddy), je nutno pou\u017e\u00edt znak \u201e_\u201c(podtr\u017e\u00edtko), nikoliv \u201e*\u201c (hv\u011bzdi\u010dku) jako v Jav\u011b. Je to z toho d\u016fvodu, \u017ee hv\u011bzdi\u010dka je v Scale platn\u00fdm identifik\u00e1torem, tak\u017ee ji nelze pou\u017e\u00edvat jako speci\u00e1ln\u00ed znak.\nKrom\u011b p\u0159\u00edm\u00e9ho vyu\u017eit\u00ed t\u0159\u00edd importovan\u00fdch z Javy, povoluje Scala definovat i jejich potomky. Tak\u00e9 je mo\u017en\u00e9 implementovat [[Rozhran\u00ed_(informatika)|rozhran\u00ed]] importovan\u00e1 z Javy.\n\nNelze ale \u0159\u00edct, \u017ee by tato spolupr\u00e1ce byla 100% bezprobl\u00e9mov\u00e1. Zaprv\u00e9, Java m\u00e1 jinou konvenci pro pojmenov\u00e1n\u00ed konstant ne\u017e Scala (''I_AM_JAVA'' vs. ''IAmScala''). Ur\u010dit\u00fdm probl\u00e9mem m\u016f\u017ee b\u00fdt tak\u00e9 fakt, \u017ee ve Scale je v\u00edce povolen\u00fdch znak\u016f pro identifik\u00e1tor. To sice nezabra\u0148uje vol\u00e1n\u00ed z Javy, proto\u017ee tyto znaky jsou p\u0159elo\u017eeny (nap\u0159. ''+'' je p\u0159elo\u017eeno jako ''$plus''), ale m\u016f\u017ee to zp\u016fsobovat ur\u010dit\u00e9 nepohodl\u00ed. U\u017eivatel Scaly by naopak mohl pova\u017eovat metodu s n\u00e1zvem ''add'' za nezvyklou, proto\u017ee se sp\u00ed\u0161e nab\u00edz\u00ed pojmenov\u00e1n\u00ed ''+'', kter\u00e9 ned\u011bl\u00e1 probl\u00e9my s prioritou p\u0159i vyu\u017eit\u00ed oper\u00e1torov\u00e9 notace.\n\nNa druhou stranu, ve Scale lze tyto probl\u00e9my obvykle celkem snadno vy\u0159e\u0161it pomoc\u00ed implicitn\u00edch konverz\u00ed.\n\n==Objektov\u011b orientovan\u00e9 rysy==\nScala je \u010dist\u011b objektov\u00fd programovac\u00ed jazyk (stejn\u011b jako Smalltalk), co\u017e znamen\u00e1, \u017ee na rozd\u00edl od Javy nezn\u00e1 \u017e\u00e1dn\u00e9  primitivn\u00ed datov\u00e9 typy. V\u0161echno (v\u010detn\u011b \u010d\u00edsel) se tv\u00e1\u0159\u00ed jako [[Objekt (programov\u00e1n\u00ed)|objekt]]. Tak\u017ee aritmetick\u00fd vyraz ''1+2'' je ekvivalentn\u00ed ''(1).+(2)'', co\u017e znamen\u00e1, \u017ee u objektu 1 vol\u00e1me metodu +, jej\u00edm\u017e parametrem je objekt 2.\nKa\u017ed\u00e1 aritmetick\u00e1 operace je ve skute\u010dnosti vol\u00e1n\u00ed p\u0159\u00edslu\u0161n\u00e9 metody. Z toho vypl\u00fdv\u00e1, \u017ee znaky +, -, <, > atd. jsou ve Scala platn\u00fdmi identifik\u00e1tory. \n==Funkcion\u00e1ln\u00ed rysy==\nSyntax Scaly podporuje [[currying]], [[anonymn\u00ed funkce]] a [[Funkcion\u00e1ln\u00ed_programov\u00e1n\u00ed#Higher-order_funkce|funkce vy\u0161\u0161\u00edch \u0159\u00e1d\u016f]], povoluje ps\u00e1t vno\u0159en\u00e9 funkce a m\u00e1 \u0159adu dal\u0161\u00edch konstrukc\u00ed typick\u00fdch pro funkcion\u00e1ln\u00ed programovac\u00ed jazyky ([[Scheme]], [[Haskell (programovac\u00ed jazyk)|Haskell]], [[Erlang (programovac\u00ed jazyk)|Erlang]] atd.) \nScala slu\u010duje mo\u017enosti [[Funkcion\u00e1ln\u00ed programov\u00e1n\u00ed|funkcion\u00e1ln\u00edho]] a [[Objektov\u011b orientovan\u00e9 programov\u00e1n\u00ed|objektov\u011b orientovan\u00e9ho programovan\u00ed]]. A je to \u010dist\u011b objektov\u00fd jazyk (objekt je cokoliv), z \u010deho\u017e vypl\u00fdv\u00e1, \u017ee jak\u00e1koliv [[Funkce (programov\u00e1n\u00ed)|funkce]] je t\u00e9\u017e [[Objekt (programov\u00e1n\u00ed)|objektem]]. Je mo\u017en\u00e9 ukl\u00e1dat funkci do prom\u011bnn\u00e9, p\u0159ed\u00e1vat funkce jako parametr do jin\u00e9 funkce nebo vr\u00e1tit jako v\u00fdsledek z jin\u00e9 funkce. Uk\u00e1\u017eeme to na p\u0159\u00edkladu:\n<source lang=\"scala\">\nobject Timer {\n    def onePerSecond(callback:()=>Unit) {\n        while(true) { callback(); Thread.sleep(1000) }\n    }\n    def timeFlies() {\n        println(\"time flies like an arrow\u2026\")\n    }\n    def main(args: Array[String]) {\n        onePerSecond(timeFlies);\n    } \n}\n</source>\nTento p\u0159\u00edklad definuje \u010dasova\u010d, kter\u00fd ka\u017edou sekundu vypisuje \u0159\u00e1dek \"time flies like an arrow\u2026\". V podstat\u011b je \u010dasova\u010d definov\u00e1n v druh\u00e9m \u0159\u00e1dku. Je to funkce ''onePerSecond'' s form\u00e1ln\u00edm parametrem ''callback'', j\u00edm\u017e m\u016f\u017ee b\u00fdt jak\u00e1koliv funkce, kter\u00e1 nem\u00e1 \u017e\u00e1dn\u00e9 parametry (o \u010dem\u017e vypov\u00eddaj\u00ed pr\u00e1zdn\u00e9 kulat\u00e9 z\u00e1vorky) a \u017e\u00e1dnou n\u00e1vratovou hodnotu (typ ''Unit'' je analogem typu ''void'' v Jav\u011b a C++).  \nD\u00e1le, je definov\u00e1na jednoduch\u00e1 funkce ''timeFlies'', kter\u00e1 jenom tiskne \u0159\u00e1dek \"time flies like an arrow\u2026\" na syst\u00e9mov\u00fd v\u00fdstup.  \nPak u\u017e ve hlavn\u00ed metod\u011b vol\u00e1me funkci ''onePerSecond'' a p\u0159ed\u00e1v\u00e1me ji jako faktick\u00fd parametr funkce ''timeFlies''.\nUveden\u00fd program obsahuje nekone\u010dn\u00fd cyklus, a proto bude opakovat v\u00fdpis \"time flies like an arrow\u2026\" dokud ho u\u017eivatel neukon\u010d\u00ed.\n\n== Extern\u00ed odkazy ==\n* [http://www.scala-lang.org http://www.scala-lang.org] \u2013 Ofici\u00e1ln\u00ed web\n* [http://www.scala-lang.org/docu/files/ScalaTutorial.pdf http://www.scala-lang.org/docu/files/ScalaTutorial.pdf] \u2013 Kr\u00e1tk\u00e1 p\u0159\u00edru\u010dka o Scale pro Java program\u00e1tory\n* [http://www.artima.com/scalazine/articles/steps.html http://www.artima.com/scalazine/articles/steps.html] \u2013 \u010cl\u00e1nek \u201eFirst steps to Scala\u201c od autora Scaly Martina Oderskeho\n* [http://blogs.sun.com/sundararajan/entry/scala_for_java_programmers http://blogs.sun.com/sundararajan/entry/scala_for_java_programmers] \u2013 Porovn\u00e1n\u00ed Javy a Scaly\n* [http://scala.sygneca.com http://scala.sygneca.com] \u2013 Wiki o jazyce Scala\n* [http://www.scala-lang.org/docu/files/ScalaReference.pdf http://www.scala-lang.org/docu/files/ScalaReference.pdf] \u2013 Specifikace jazyka Scala\n* [http://www.scala-lang.org/docu/files/api/index.html http://www.scala-lang.org/docu/files/api/index.html] \u2013 Scala API\n\n{{Programovac\u00ed jazyky}}\n\n[[Kategorie:Programovac\u00ed jazyky]]\n[[Kategorie:JVM programovac\u00ed jazyky]]"
          }
        ]
      }
    }
  }
}